classdef AveragePooling2DGPUStrategy < nnet.internal.cnn.layer.util.ExecutionStrategy
    % AveragePooling2DGPUStrategy   Execution strategy for running the average pooling on the GPU
    
    %   Copyright 2016-2017 The MathWorks, Inc.
    
    methods
        function [Z, memory] = forward(~, X, ...
                poolHeight, poolWidth, ...
                topPad, leftPad, ...
                bottomPad, rightPad, ...
                verticalStride, horizontalStride)
            paddingSize = [topPad bottomPad leftPad rightPad];
            if iPaddingIsSymmetric(paddingSize)
                Z = nnet.internal.cnngpu.poolingAverageForward2D(X, ...
                    poolHeight, poolWidth, ...
                    topPad, leftPad, ...
                    bottomPad, rightPad, ...
                    verticalStride, horizontalStride);
            else
                X = iPadArray(X, paddingSize);
                Z = nnet.internal.cnngpu.poolingAverageForward2D(X, ...
                    poolHeight, poolWidth, ...
                    0, 0, ...
                    0, 0, ...
                    verticalStride, horizontalStride);
            end
            memory = [];
        end
        
        function [dX,dW] = backward( ~, ...
                Z, dZ, X, ...
                poolHeight, poolWidth, ...
                topPad, leftPad, ...
                bottomPad, rightPad, ...
                strideHeight, strideWidth)
            paddingSize = [topPad bottomPad leftPad rightPad];
            if iPaddingIsSymmetric(paddingSize)
                dX = nnet.internal.cnngpu.poolingAverageBackward2D( ...
                    Z, dZ, X, ...
                    poolHeight, poolWidth, ...
                    topPad, leftPad, ...
                    bottomPad, rightPad, ...
                    strideHeight, strideWidth);
            else
                X = iPadArray(X, paddingSize);
                dX = nnet.internal.cnngpu.poolingAverageBackward2D( ...
                    Z, dZ, X, ...
                    poolHeight, poolWidth, ...
                    0, 0, ...
                    0, 0, ...
                    strideHeight, strideWidth);
                dX = iUnpadArray(dX, paddingSize);
            end
            dW = []; % No learnable weights
        end
        
    end
end

function tf = iPaddingIsSymmetric(paddingSize)
tf = nnet.internal.cnn.layer.padding.isPaddingSymmetric(paddingSize);
end

function outputArray = iPadArray(inputArray, paddingSize)
outputArray = nnet.internal.cnn.layer.padding.padArray(inputArray, paddingSize);
end

function outputArray = iUnpadArray(inputArray, paddingSize)
outputArray = nnet.internal.cnn.layer.padding.unpadArray(inputArray, paddingSize);
end